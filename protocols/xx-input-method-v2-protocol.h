/* Generated by wayland-scanner 1.24.0 */

#ifndef INPUT_METHOD_EXPERIMENTAL_V2_CLIENT_PROTOCOL_H
#define INPUT_METHOD_EXPERIMENTAL_V2_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_input_method_experimental_v2 The input_method_experimental_v2 protocol
 * Protocol for creating input methods
 *
 * @section page_desc_input_method_experimental_v2 Description
 *
 * This protocol allows applications to act as input methods for compositors.
 *
 * An input method context is used to manage the state of the input method.
 *
 * Text strings are UTF-8 encoded, their indices and lengths are in bytes.
 *
 * This document adheres to the RFC 2119 when using words like "must",
 * "should", "may", etc.
 *
 * Warning! The protocol described in this file is currently in the
 * experimental phase. Backwards incompatible major versions of the
 * protocol are to be expected. Exposing this protocol without an opt-in
 * mechanism is discouraged.
 *
 * @section page_ifaces_input_method_experimental_v2 Interfaces
 * - @subpage page_iface_xx_input_method_v1 - input method
 * - @subpage page_iface_xx_input_popup_surface_v2 - popup surface
 * - @subpage page_iface_xx_input_popup_positioner_v1 - input method popup positioner
 * - @subpage page_iface_xx_input_method_manager_v2 - input method manager
 * @section page_copyright_input_method_experimental_v2 Copyright
 * <pre>
 *
 * Copyright © 2008-2011 Kristian Høgsberg
 * Copyright © 2010-2011 Intel Corporation
 * Copyright © 2012-2013 Collabora, Ltd.
 * Copyright © 2012, 2013 Intel Corporation
 * Copyright © 2015, 2016 Jan Arne Petersen
 * Copyright © 2017, 2018 Red Hat, Inc.
 * Copyright © 2018       Purism SPC
 * Copyright © 2025       DorotaC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_seat;
struct wl_surface;
struct xx_input_method_manager_v2;
struct xx_input_method_v1;
struct xx_input_popup_positioner_v1;
struct xx_input_popup_surface_v2;

#ifndef XX_INPUT_METHOD_V1_INTERFACE
#define XX_INPUT_METHOD_V1_INTERFACE
/**
 * @page page_iface_xx_input_method_v1 xx_input_method_v1
 * @section page_iface_xx_input_method_v1_desc Description
 *
 * An input method object allows for clients to compose text.
 *
 * The objects connects the client to a text input in an application, and
 * lets the client to serve as an input method for a seat.
 *
 * The xx_input_method_v1 object can occupy two distinct states: active and
 * inactive. In the active state, the object is associated to and
 * communicates with a text input. In the inactive state, there is no
 * associated text input, and the only communication is with the compositor.
 * Initially, the input method is in the inactive state.
 *
 * Requests issued in the inactive state must be accepted by the compositor.
 * Because of the serial mechanism, and the state reset on activate event,
 * they will not have any effect on the state of the next text input.
 *
 * There must be no more than one input method object per seat.
 * @section page_iface_xx_input_method_v1_api API
 * See @ref iface_xx_input_method_v1.
 */
/**
 * @defgroup iface_xx_input_method_v1 The xx_input_method_v1 interface
 *
 * An input method object allows for clients to compose text.
 *
 * The objects connects the client to a text input in an application, and
 * lets the client to serve as an input method for a seat.
 *
 * The xx_input_method_v1 object can occupy two distinct states: active and
 * inactive. In the active state, the object is associated to and
 * communicates with a text input. In the inactive state, there is no
 * associated text input, and the only communication is with the compositor.
 * Initially, the input method is in the inactive state.
 *
 * Requests issued in the inactive state must be accepted by the compositor.
 * Because of the serial mechanism, and the state reset on activate event,
 * they will not have any effect on the state of the next text input.
 *
 * There must be no more than one input method object per seat.
 */
extern const struct wl_interface xx_input_method_v1_interface;
#endif
#ifndef XX_INPUT_POPUP_SURFACE_V2_INTERFACE
#define XX_INPUT_POPUP_SURFACE_V2_INTERFACE
/**
 * @page page_iface_xx_input_popup_surface_v2 xx_input_popup_surface_v2
 * @section page_iface_xx_input_popup_surface_v2_desc Description
 *
 * An input method popup surface is a short-lived, temporary surface.
 * It is meant as an area to show suggestions, candidates, or for other input-related uses.
 *
 * The compositor should anchor it at the active text input cursor area.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for input_popup_surface state updates to take effect, unless otherwise noted.
 *
 * After the initial wl_surface.commit, the compositor must reply with a configure sequence (see .start_configure) initializing all the compositor-provided state of the popup. That means providing values for:
 *
 * - width
 * - height
 * - anchor_x
 * - anchor_y
 * - anchor_width
 * - anchor_height
 * - serial
 *
 * using the appropriate events.
 *
 * The popup will only be presented to the user after the client receives the configure sequence and replies with .ack_configure.
 *
 * An example init sequence could look like this:
 *
 * 1. client (Cl): popup = input_method.get_popup(wl_surface, positioner)
 * 2. Cl: wl_surface.commit()
 * 3. compositor (Co): popup.start_configure(150, 150, 10, -2, 5, 30)
 * 5. Co: input_method.done()
 * 6. Cl: ack_configure()
 * 7. Cl: wl_surface.commit()
 *
 * A newly created input_popup_surface will be stacked on top of all previously created
 * input_popup_surfaces associated with the same text input.
 *
 * A typical sequence resulting from the user selecting a new text field and typing some text:
 *
 * 1. compositor (Co): input_method.activate()
 * 2. Co: input_method.done()
 * 3. [init sequence]
 * 4. Co: input_method.set_surrounding_text("new text")
 * 5. Co: popup.start_configure(150, 150, -60, -2, 55, 30)
 * 6. Co: input_method.done()
 * 7. client (Cl): ack_configure()
 * 8. Cl: wl_surface.commit()
 *
 * When the corresponding input_method receives a commited .deactivate event, the popup gets destroyed and becomes invalid and its surface gets unmapped.
 *
 * The client must not destroy the underlying wl_surface while the
 * xx_input_popup_surface_v2 object exists.
 * @section page_iface_xx_input_popup_surface_v2_api API
 * See @ref iface_xx_input_popup_surface_v2.
 */
/**
 * @defgroup iface_xx_input_popup_surface_v2 The xx_input_popup_surface_v2 interface
 *
 * An input method popup surface is a short-lived, temporary surface.
 * It is meant as an area to show suggestions, candidates, or for other input-related uses.
 *
 * The compositor should anchor it at the active text input cursor area.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for input_popup_surface state updates to take effect, unless otherwise noted.
 *
 * After the initial wl_surface.commit, the compositor must reply with a configure sequence (see .start_configure) initializing all the compositor-provided state of the popup. That means providing values for:
 *
 * - width
 * - height
 * - anchor_x
 * - anchor_y
 * - anchor_width
 * - anchor_height
 * - serial
 *
 * using the appropriate events.
 *
 * The popup will only be presented to the user after the client receives the configure sequence and replies with .ack_configure.
 *
 * An example init sequence could look like this:
 *
 * 1. client (Cl): popup = input_method.get_popup(wl_surface, positioner)
 * 2. Cl: wl_surface.commit()
 * 3. compositor (Co): popup.start_configure(150, 150, 10, -2, 5, 30)
 * 5. Co: input_method.done()
 * 6. Cl: ack_configure()
 * 7. Cl: wl_surface.commit()
 *
 * A newly created input_popup_surface will be stacked on top of all previously created
 * input_popup_surfaces associated with the same text input.
 *
 * A typical sequence resulting from the user selecting a new text field and typing some text:
 *
 * 1. compositor (Co): input_method.activate()
 * 2. Co: input_method.done()
 * 3. [init sequence]
 * 4. Co: input_method.set_surrounding_text("new text")
 * 5. Co: popup.start_configure(150, 150, -60, -2, 55, 30)
 * 6. Co: input_method.done()
 * 7. client (Cl): ack_configure()
 * 8. Cl: wl_surface.commit()
 *
 * When the corresponding input_method receives a commited .deactivate event, the popup gets destroyed and becomes invalid and its surface gets unmapped.
 *
 * The client must not destroy the underlying wl_surface while the
 * xx_input_popup_surface_v2 object exists.
 */
extern const struct wl_interface xx_input_popup_surface_v2_interface;
#endif
#ifndef XX_INPUT_POPUP_POSITIONER_V1_INTERFACE
#define XX_INPUT_POPUP_POSITIONER_V1_INTERFACE
/**
 * @page page_iface_xx_input_popup_positioner_v1 xx_input_popup_positioner_v1
 * @section page_iface_xx_input_popup_positioner_v1_desc Description
 *
 * The input_popup_positioner provides a collection of rules for the placement of an input method popup surface relative to the cursor.
 * Rules can be defined to ensure
 * the text input area remains within the visible area's borders, and to
 * specify how the popup changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a popup must intersect with or
 * be at least partially adjacent to the surface containing the text input.
 *
 * See the various requests for details about possible rules.
 *
 * A newly created positioner has the following state:
 * - 0 surface width
 * - 0 surface height
 * - anchor at the center ("none")
 * - gravity towards the center ("none")
 * - constraints adjustment set to none
 * - offset at x = 0, y = 0
 * - not reactive
 *
 * Upon receiving a request taking the positioner as an argument, the compositor makes a copy of the rules
 * specified by the input_popup_positioner. Thus, after the request is complete the
 * input_popup_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an input_popup_positioner object to be considered complete, its state must contain a non-zero width and height. Passing an incomplete input_popup_positioner object when
 * positioning a surface raises an invalid_positioner error.
 * @section page_iface_xx_input_popup_positioner_v1_api API
 * See @ref iface_xx_input_popup_positioner_v1.
 */
/**
 * @defgroup iface_xx_input_popup_positioner_v1 The xx_input_popup_positioner_v1 interface
 *
 * The input_popup_positioner provides a collection of rules for the placement of an input method popup surface relative to the cursor.
 * Rules can be defined to ensure
 * the text input area remains within the visible area's borders, and to
 * specify how the popup changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a popup must intersect with or
 * be at least partially adjacent to the surface containing the text input.
 *
 * See the various requests for details about possible rules.
 *
 * A newly created positioner has the following state:
 * - 0 surface width
 * - 0 surface height
 * - anchor at the center ("none")
 * - gravity towards the center ("none")
 * - constraints adjustment set to none
 * - offset at x = 0, y = 0
 * - not reactive
 *
 * Upon receiving a request taking the positioner as an argument, the compositor makes a copy of the rules
 * specified by the input_popup_positioner. Thus, after the request is complete the
 * input_popup_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an input_popup_positioner object to be considered complete, its state must contain a non-zero width and height. Passing an incomplete input_popup_positioner object when
 * positioning a surface raises an invalid_positioner error.
 */
extern const struct wl_interface xx_input_popup_positioner_v1_interface;
#endif
#ifndef XX_INPUT_METHOD_MANAGER_V2_INTERFACE
#define XX_INPUT_METHOD_MANAGER_V2_INTERFACE
/**
 * @page page_iface_xx_input_method_manager_v2 xx_input_method_manager_v2
 * @section page_iface_xx_input_method_manager_v2_desc Description
 *
 * The input method manager allows the client to become the input method on
 * a chosen seat.
 *
 * No more than one input method must be associated with any seat at any
 * given time.
 * @section page_iface_xx_input_method_manager_v2_api API
 * See @ref iface_xx_input_method_manager_v2.
 */
/**
 * @defgroup iface_xx_input_method_manager_v2 The xx_input_method_manager_v2 interface
 *
 * The input method manager allows the client to become the input method on
 * a chosen seat.
 *
 * No more than one input method must be associated with any seat at any
 * given time.
 */
extern const struct wl_interface xx_input_method_manager_v2_interface;
#endif

#ifndef XX_INPUT_METHOD_V1_ERROR_ENUM
#define XX_INPUT_METHOD_V1_ERROR_ENUM
enum xx_input_method_v1_error {
	/**
	 * surface already has a role
	 */
	XX_INPUT_METHOD_V1_ERROR_SURFACE_HAS_ROLE = 0x0,
	/**
	 * operation requires the input method to be active
	 */
	XX_INPUT_METHOD_V1_ERROR_INACTIVE = 0x1,
};
#endif /* XX_INPUT_METHOD_V1_ERROR_ENUM */

#ifndef XX_INPUT_METHOD_V1_PROTOCOL_COMPAT_ENUM
#define XX_INPUT_METHOD_V1_PROTOCOL_COMPAT_ENUM
/**
 * @ingroup iface_xx_input_method_v1
 * protocol comatibility value
 *
 * Tells the input method client what kinds of events the text input client supports.
 */
enum xx_input_method_v1_protocol_compat {
	/**
	 * zwp-text-input-v3 semantics
	 */
	XX_INPUT_METHOD_V1_PROTOCOL_COMPAT_TEXT_INPUT_V3 = 0x0,
	/**
	 * xx-text-input semantics
	 *
	 * Changes the meaning of serial compared to v3. The text input
	 * client now applies requested updates on a "best-effort" basis.
	 */
	XX_INPUT_METHOD_V1_PROTOCOL_COMPAT_XX_TEXT_INPUT = 0x1,
};
#endif /* XX_INPUT_METHOD_V1_PROTOCOL_COMPAT_ENUM */

/**
 * @ingroup iface_xx_input_method_v1
 * @struct xx_input_method_v1_listener
 */
struct xx_input_method_v1_listener {
	/**
	 * input method has been requested
	 *
	 * Notification that a text input focused on this seat requested
	 * the input method to be activated.
	 *
	 * This event serves the purpose of providing the compositor with
	 * an active input method.
	 *
	 * This event resets all state associated with previous
	 * surrounding_text, text_change_cause, and content_type events, as
	 * well as the state associated with set_preedit_string,
	 * commit_string, and delete_surrounding_text requests, and
	 * destroys any existing input_popup_surface objects. In addition,
	 * it marks the xx_input_method_v1 object as active.
	 *
	 * The surrounding_text, and content_type events must follow before
	 * the next done event if the text input supports the respective
	 * functionality.
	 *
	 * State set with this event is double-buffered. It will get
	 * applied on the next xx_input_method_v1.done event, and stay
	 * valid until changed.
	 */
	void (*activate)(void *data,
			 struct xx_input_method_v1 *xx_input_method_v1);
	/**
	 * deactivate event
	 *
	 * Notification that no focused text input currently needs an
	 * active input method on this seat.
	 *
	 * This event marks the xx_input_method_v1 object as inactive.
	 * compositor must destroy all existing xx_input_popup_surface_v2
	 * objects.
	 *
	 * This event resets all state associated with previous
	 * surrounding_text, text_change_cause, and content_type events, as
	 * well as the state associated with set_preedit_string,
	 * commit_string, and delete_surrounding_text requests.
	 *
	 * State set with this event is double-buffered. It will get
	 * applied on the next xx_input_method_v1.done event, and stay
	 * valid until changed.
	 */
	void (*deactivate)(void *data,
			   struct xx_input_method_v1 *xx_input_method_v1);
	/**
	 * surrounding text event
	 *
	 * Updates the surrounding plain text around the cursor,
	 * excluding the preedit text.
	 *
	 * If any preedit text is present, it is replaced with the cursor
	 * for the purpose of this event.
	 *
	 * The argument text is a buffer containing the preedit string, and
	 * must include the cursor position, and the complete selection. It
	 * should contain additional characters before and after these.
	 * There is a maximum length of wayland messages, so text can not
	 * be longer than 4000 bytes.
	 *
	 * cursor is the byte offset of the cursor within the text buffer.
	 *
	 * anchor is the byte offset of the selection anchor within the
	 * text buffer. If there is no selected text, anchor must be the
	 * same as cursor.
	 *
	 * If this event does not arrive before the first done event, the
	 * input method may assume that the text input does not support
	 * this functionality and ignore following surrounding_text events.
	 *
	 * Values set with this event are double-buffered. They will get
	 * applied and set to initial values on the next
	 * xx_input_method_v1.done event.
	 *
	 * The initial state for affected fields is empty, meaning that the
	 * text input does not support sending surrounding text. If the
	 * empty values get applied, subsequent attempts to change them may
	 * have no effect.
	 */
	void (*surrounding_text)(void *data,
				 struct xx_input_method_v1 *xx_input_method_v1,
				 const char *text,
				 uint32_t cursor,
				 uint32_t anchor);
	/**
	 * indicates the cause of surrounding text change
	 *
	 * Tells the input method why the text surrounding the cursor
	 * changed.
	 *
	 * Whenever the client detects an external change in text, cursor,
	 * or anchor position, it must issue this request to the
	 * compositor. This request is intended to give the input method a
	 * chance to update the preedit text in an appropriate way, e.g. by
	 * removing it when the user starts typing with a keyboard.
	 *
	 * cause describes the source of the change.
	 *
	 * The value set with this event is double-buffered. It will get
	 * applied and set to its initial value on the next
	 * xx_input_method_v1.done event.
	 *
	 * The initial value of cause is input_method.
	 */
	void (*text_change_cause)(void *data,
				  struct xx_input_method_v1 *xx_input_method_v1,
				  uint32_t cause);
	/**
	 * content purpose and hint
	 *
	 * Indicates the content type and hint for the current
	 * xx_input_method_v1 instance.
	 *
	 * Values set with this event are double-buffered. They will get
	 * applied on the next xx_input_method_v1.done event. They get
	 * reset to initial on the next committed deactivate event.
	 *
	 * The initial value for hint is none, and the initial value for
	 * purpose is normal.
	 */
	void (*content_type)(void *data,
			     struct xx_input_method_v1 *xx_input_method_v1,
			     uint32_t hint,
			     uint32_t purpose);
	/**
	 * announce the available actions
	 *
	 * Announces the actions available for the currently active text
	 * input.
	 *
	 * Values set with this event are double-buffered. They will get
	 * applied on the next .done event. They get reset to the initial
	 * value on the next committed deactivate event.
	 *
	 * The initial value is an empty set: no actions are available.
	 *
	 * Values in the available_actions array come from
	 * text-input-v3.action.
	 * @param available_actions available actions
	 * @since 3
	 */
	void (*set_available_actions)(void *data,
				      struct xx_input_method_v1 *xx_input_method_v1,
				      struct wl_array *available_actions);
	/**
	 * announce extra supported features
	 *
	 * Notifies the input method what the currently active text input
	 * client is able to do.
	 *
	 * This event should come within the same .done sequence as
	 * .activate. Otherwise, the input method may ignore it.
	 *
	 * Values set with this event are double-buffered. They will get
	 * applied on the next .done event. They get reset to initial on
	 * the next committed deactivate event.
	 *
	 * The initial value for features is none.
	 * @since 3
	 */
	void (*announce_supported_features)(void *data,
					    struct xx_input_method_v1 *xx_input_method_v1,
					    uint32_t features);
	/**
	 * set text input's compatibility level
	 *
	 * Tells the input method client what kinds of events the text
	 * input client supports.
	 *
	 * Values set with this event are double-buffered. They will get
	 * applied on the next .done event. They get reset to initial on
	 * the next committed deactivate event.
	 *
	 * The compositor may send this event as part of a .done chain that
	 * switches the active state from inactive to active. It must not
	 * send this event otherwise.
	 *
	 * The initial value for version is text_input_v3.
	 * @since 3
	 */
	void (*announce_protocol_compat)(void *data,
					 struct xx_input_method_v1 *xx_input_method_v1,
					 uint32_t compat_level);
	/**
	 * apply state
	 *
	 * Atomically applies state changes recently sent to the client.
	 *
	 * The done event establishes and updates the state of the client,
	 * and must be issued after any changes to apply them.
	 *
	 * Text input state (content purpose, content hint, surrounding
	 * text, and change cause) is conceptually double-buffered within
	 * an input method context.
	 *
	 * Events modify the pending state, as opposed to the current state
	 * in use by the input method. A done event atomically applies all
	 * pending state, replacing the current state. After done, the new
	 * pending state is as documented for each related request.
	 *
	 * Events must be applied in the order of arrival.
	 *
	 * Neither current nor pending state are modified unless noted
	 * otherwise.
	 */
	void (*done)(void *data,
		     struct xx_input_method_v1 *xx_input_method_v1);
	/**
	 * input method unavailable
	 *
	 * The input method ceased to be available.
	 *
	 * The compositor must issue this event as the only event on the
	 * object if there was another input_method object associated with
	 * the same seat at the time of its creation.
	 *
	 * The compositor must issue this request when the object is no
	 * longer useable, e.g. due to seat removal.
	 *
	 * The input method context becomes inert and should be destroyed
	 * after deactivation is handled. Any further requests and events
	 * except for the destroy request must be ignored.
	 */
	void (*unavailable)(void *data,
			    struct xx_input_method_v1 *xx_input_method_v1);
};

/**
 * @ingroup iface_xx_input_method_v1
 */
static inline int
xx_input_method_v1_add_listener(struct xx_input_method_v1 *xx_input_method_v1,
				const struct xx_input_method_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xx_input_method_v1,
				     (void (**)(void)) listener, data);
}

#define XX_INPUT_METHOD_V1_PERFORM_ACTION 0
#define XX_INPUT_METHOD_V1_COMMIT_STRING 1
#define XX_INPUT_METHOD_V1_SET_PREEDIT_STRING 2
#define XX_INPUT_METHOD_V1_DELETE_SURROUNDING_TEXT 3
#define XX_INPUT_METHOD_V1_MOVE_CURSOR 4
#define XX_INPUT_METHOD_V1_COMMIT 5
#define XX_INPUT_METHOD_V1_GET_INPUT_POPUP_SURFACE 6
#define XX_INPUT_METHOD_V1_DESTROY 7

/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_ACTIVATE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_DEACTIVATE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_SURROUNDING_TEXT_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_TEXT_CHANGE_CAUSE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_CONTENT_TYPE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_SET_AVAILABLE_ACTIONS_SINCE_VERSION 3
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_ANNOUNCE_SUPPORTED_FEATURES_SINCE_VERSION 3
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_ANNOUNCE_PROTOCOL_COMPAT_SINCE_VERSION 3
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_UNAVAILABLE_SINCE_VERSION 1

/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_PERFORM_ACTION_SINCE_VERSION 3
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_COMMIT_STRING_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_SET_PREEDIT_STRING_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_DELETE_SURROUNDING_TEXT_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_MOVE_CURSOR_SINCE_VERSION 3
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_COMMIT_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_GET_INPUT_POPUP_SURFACE_SINCE_VERSION 2
/**
 * @ingroup iface_xx_input_method_v1
 */
#define XX_INPUT_METHOD_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_xx_input_method_v1 */
static inline void
xx_input_method_v1_set_user_data(struct xx_input_method_v1 *xx_input_method_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xx_input_method_v1, user_data);
}

/** @ingroup iface_xx_input_method_v1 */
static inline void *
xx_input_method_v1_get_user_data(struct xx_input_method_v1 *xx_input_method_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xx_input_method_v1);
}

static inline uint32_t
xx_input_method_v1_get_version(struct xx_input_method_v1 *xx_input_method_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Perform an action on this text input.
 *
 * Values set with this event are double-buffered. They must be applied
 * and reset to initial on the next commit request.
 *
 * The initial value of action is none.
 */
static inline void
xx_input_method_v1_perform_action(struct xx_input_method_v1 *xx_input_method_v1, uint32_t action)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_PERFORM_ACTION, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, action);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Send the commit string text for insertion to the application.
 *
 * Inserts a string at current cursor position (see commit event
 * sequence). The string to commit could be either just a single character
 * after a key press or the result of some composing.
 *
 * The argument text is a buffer containing the string to insert. There is
 * a maximum length of wayland messages, so text can not be longer than
 * 4000 bytes.
 *
 * Values set with this request are double-buffered. They must be applied
 * and reset to initial on the next .commit request.
 *
 * The initial value of text is an empty string.
 */
static inline void
xx_input_method_v1_commit_string(struct xx_input_method_v1 *xx_input_method_v1, const char *text)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_COMMIT_STRING, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, text);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Send the pre-edit string text to the application text input.
 *
 * Place a new composing text (pre-edit) at the current cursor position.
 * Any previously set composing text must be removed. Any previously
 * existing selected text must be removed. The cursor is moved to a new
 * position within the preedit string.
 *
 * The argument text is a buffer containing the preedit string. There is
 * a maximum length of wayland messages, so text can not be longer than
 * 4000 bytes.
 *
 * The arguments cursor_begin and cursor_end are counted in bytes relative
 * to the beginning of the submitted string buffer. Cursor should be
 * hidden by the text input when both are equal to -1.
 *
 * cursor_begin indicates the beginning of the cursor. cursor_end
 * indicates the end of the cursor. It may be equal or different than
 * cursor_begin.
 *
 * Values set with this request are double-buffered. They must be applied on
 * the next xx_input_method_v1.commit request.
 * They must be reset to initial on the next committed .deactivate event.
 *
 * The initial value of text is an empty string. The initial value of
 * cursor_begin, and cursor_end are both 0.
 */
static inline void
xx_input_method_v1_set_preedit_string(struct xx_input_method_v1 *xx_input_method_v1, const char *text, int32_t cursor_begin, int32_t cursor_end)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_SET_PREEDIT_STRING, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, text, cursor_begin, cursor_end);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Remove the surrounding text.
 *
 * before_length and after_length are the number of bytes before and after
 * the current cursor index (excluding the preedit text) to delete.
 *
 * If text is selected, it must be deleted.
 *
 * If indices exceed the available text boundaries, they should be adjusted to fit in boundaries and deletion reattempted.
 * If indices do not lie on byte boundaries, then the text input client should delete at least that many bytes. In this case, the client decides the end point, but a character boundary same as when deleting using the keyboard is recommended.
 *
 * If any preedit text is present, it is replaced with the cursor for the
 * purpose of this event. In effect before_length is counted from the
 * beginning of preedit text, and after_length from its end (see commit
 * event sequence).
 *
 * Values set with this request are double-buffered. They must be applied
 * and reset to initial on the next xx_input_method_v1.commit request.
 *
 * The initial values of both before_length and after_length are 0.
 */
static inline void
xx_input_method_v1_delete_surrounding_text(struct xx_input_method_v1 *xx_input_method_v1, uint32_t before_length, uint32_t after_length)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_DELETE_SURROUNDING_TEXT, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, before_length, after_length);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Unselects text, moves the cursor and selects text.
 *
 * This is equivalent to dragging the mouse over some text: it deselects whatever might be currently selected and selects a new range of text.
 *
 * The offsets used in arguments are in bytes relative to the current cursor position. Cursor is the new position of the cursor, and anchor is the opposite end of selection. If there's no selection, anchor should be equal to cursor.
 *
 * The offsets do not take preedit contents into account, nor is preedit changed in any way with this request.
 *
 * Both cursor and anchor must fall on code point boundaries, otherwise text input client may ignore the request. It is therefore not recommended for an input method to move any of them beyond the text received in surrounding_text.
 *
 * When surrounding_text is not supported, the offsets must not be interpreted as bytes, but as some human-readable unit at least as big as a code point, for example a grapheme.
 *
 * The cursor and anchor arguments can also take the following special values:
 * BEGINNING := 0x8000_0000 = i32::MIN
 * END := 0x7fff_ffff = i32::MAX
 * meaning, respectively, the beginning and the end of of all text in the input field.
 *
 * Values set with this event are double-buffered. They must be applied
 * and reset to initial on the next commit request.
 *
 * The initial values of both cursor and anchor are 0.
 */
static inline void
xx_input_method_v1_move_cursor(struct xx_input_method_v1 *xx_input_method_v1, int32_t cursor, int32_t anchor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_MOVE_CURSOR, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, cursor, anchor);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Apply state changes from commit_string, set_preedit_string and
 * delete_surrounding_text requests.
 *
 * The state relating to these events is double-buffered, and each one
 * modifies the pending state. This request replaces the current state
 * with the pending state.
 *
 * The connected text input is expected to proceed by evaluating the
 * changes in the following order:
 *
 * 1. Replace existing preedit string with the cursor.
 * 2. Delete requested surrounding text.
 * 3. Insert commit string with the cursor at its end.
 * 4. Move the cursor and selection.
 * 5. Calculate surrounding text to send.
 * 6. Insert new preedit text in cursor position.
 * 7. Place cursor inside preedit text.
 * 8. Perform the requested action.
 *
 * Note that the input method can not receive more than 4000 bytes of selection text, which might be the case for example when the entire document is selected. Nevertheless, the text input must delete the entire selected range before inserting the commit string.
 *
 * Serial handling with protocol_compat == xx_text_input
 *
 * The serial number should be set to 0.
 *
 * Serial handling with protocol_compat == text_input_v3
 *
 * The serial number reflects the last state of the xx_input_method_v1
 * object known to the client. The value of the serial argument must be
 * equal to the number of done events already issued by that object. When
 * the compositor receives a commit request with a serial different than
 * the number of past done events, it must proceed as normal, except it
 * should not change the current state of the xx_input_method_v1 object.
 */
static inline void
xx_input_method_v1_commit(struct xx_input_method_v1 *xx_input_method_v1, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_COMMIT, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, serial);
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Creates a new xx_input_popup_surface_v2 object wrapping a given
 * surface.
 *
 * The surface gets assigned the "input_popup" role. If the surface
 * already has an assigned role, the compositor must issue a protocol
 * error.
 *
 * Issuing this request before receiving a committed .activate causes the "inactive" error.
 */
static inline struct xx_input_popup_surface_v2 *
xx_input_method_v1_get_input_popup_surface(struct xx_input_method_v1 *xx_input_method_v1, struct wl_surface *surface, struct xx_input_popup_positioner_v1 *positioner)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_GET_INPUT_POPUP_SURFACE, &xx_input_popup_surface_v2_interface, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), 0, NULL, surface, positioner);

	return (struct xx_input_popup_surface_v2 *) id;
}

/**
 * @ingroup iface_xx_input_method_v1
 *
 * Destroys the xx_input_method_v1 object and any associated child
 * objects.
 */
static inline void
xx_input_method_v1_destroy(struct xx_input_method_v1 *xx_input_method_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_v1,
			 XX_INPUT_METHOD_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef XX_INPUT_POPUP_SURFACE_V2_ERROR_ENUM
#define XX_INPUT_POPUP_SURFACE_V2_ERROR_ENUM
enum xx_input_popup_surface_v2_error {
	/**
	 * received acknowledgement for a serial which has already been acknowledged or has never been issued
	 */
	XX_INPUT_POPUP_SURFACE_V2_ERROR_INVALID_SERIAL = 0,
};
#endif /* XX_INPUT_POPUP_SURFACE_V2_ERROR_ENUM */

/**
 * @ingroup iface_xx_input_popup_surface_v2
 * @struct xx_input_popup_surface_v2_listener
 */
struct xx_input_popup_surface_v2_listener {
	/**
	 * configure the popup surface
	 *
	 * The start_configure event updates the popup geometry and marks
	 * the start of a configure sequence.
	 *
	 * The anchor_* arguments represent the geometry of the anchor to
	 * which the popup was attached, relative to the upper left corner
	 * of the popup's surface. Note that this makes anchor_x, anchor_y
	 * the reverse of the what they represent in xdg_popup.
	 *
	 * A configure sequence is a set of one or more events configuring
	 * the state of the input_popup_surface, starting with this event
	 * and ending with input_method.done. After the input_method.done
	 * event, the configure sequence is considered submitted.
	 *
	 * State set by event in a configure sequence is conceptually
	 * double-buffered. Every argument overwrites its previous value.
	 * The state change should get applied atomically with the
	 * input_method.done ending the sequence, and the value of serial
	 * should return to the undefined value.
	 *
	 * Events on the input_popup_surface object received outside a
	 * configure sequence (while serial is undefined) must be ignored
	 * by the client.
	 *
	 * A configure sequence shall be sent every time the compositor
	 * (re)positions the popup, or the shape of the anchor changes, for
	 * example after popup creation, or in response to text being typed
	 * and the text cursor moving.
	 *
	 * The client may update the surface in response to
	 * input_method.done. Unless the popup is destroyed by the
	 * input_method.done, the client must reply with an .ack_configure
	 * request with the serial sent in the start_configure event at
	 * some point after the sequence ends and before committing the new
	 * surface.
	 *
	 * If the client receives multiple configure sequences before it
	 * can respond to one, it is free to discard all but the last event
	 * it received.
	 * @param width popup width
	 * @param height popup height
	 * @param anchor_x x position relative to anchor geometry
	 * @param anchor_y y position relative to anchor geometry
	 * @param anchor_width width of the anchor area
	 * @param anchor_height height of the anchor area
	 * @param serial serial of the configure sequence
	 */
	void (*start_configure)(void *data,
				struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2,
				uint32_t width,
				uint32_t height,
				int32_t anchor_x,
				int32_t anchor_y,
				uint32_t anchor_width,
				uint32_t anchor_height,
				uint32_t serial);
	/**
	 * signal the completion of a reposition request
	 *
	 * The compositor sends the .repositioned event in response to
	 * the .reposition request to notify about its completion.
	 *
	 * The new geometry of the popup can be communicated using
	 * additional events within a configure sequence including: -
	 * input_popup_surface.start_configure, and - the .anchor_position
	 * event to update the relative position to the anchor.
	 *
	 * When responding to a .reposition request, the token argument is
	 * the token passed in the that request.
	 *
	 * This event is sent as part of a configure sequence. State set by
	 * this event is conceptually double-buffered. Every argument
	 * overwrites its previous value. The state change should get
	 * applied atomically with the next input_method.done event.
	 *
	 * The client should optionally update the content of the popup,
	 * but must acknowledge the new popup configuration for the new
	 * position to take effect. See input_popup_surface.ack_configure
	 * for details.
	 * @param token reposition request token
	 */
	void (*repositioned)(void *data,
			     struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2,
			     uint32_t token);
};

/**
 * @ingroup iface_xx_input_popup_surface_v2
 */
static inline int
xx_input_popup_surface_v2_add_listener(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2,
				       const struct xx_input_popup_surface_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xx_input_popup_surface_v2,
				     (void (**)(void)) listener, data);
}

#define XX_INPUT_POPUP_SURFACE_V2_ACK_CONFIGURE 0
#define XX_INPUT_POPUP_SURFACE_V2_REPOSITION 1
#define XX_INPUT_POPUP_SURFACE_V2_DESTROY 2

/**
 * @ingroup iface_xx_input_popup_surface_v2
 */
#define XX_INPUT_POPUP_SURFACE_V2_START_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_surface_v2
 */
#define XX_INPUT_POPUP_SURFACE_V2_REPOSITIONED_SINCE_VERSION 1

/**
 * @ingroup iface_xx_input_popup_surface_v2
 */
#define XX_INPUT_POPUP_SURFACE_V2_ACK_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_surface_v2
 */
#define XX_INPUT_POPUP_SURFACE_V2_REPOSITION_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_surface_v2
 */
#define XX_INPUT_POPUP_SURFACE_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_xx_input_popup_surface_v2 */
static inline void
xx_input_popup_surface_v2_set_user_data(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xx_input_popup_surface_v2, user_data);
}

/** @ingroup iface_xx_input_popup_surface_v2 */
static inline void *
xx_input_popup_surface_v2_get_user_data(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xx_input_popup_surface_v2);
}

static inline uint32_t
xx_input_popup_surface_v2_get_version(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) xx_input_popup_surface_v2);
}

/**
 * @ingroup iface_xx_input_popup_surface_v2
 *
 * This request notifies the compositor that the client updated its surface in response to a configure sequence.
 *
 * The purpose of this request is to synchronize the updates of the surface geometry with the surface contents.
 * For example, when the compositor assigns a size larger than prevously, the client must fill the additional space before the popup gets displayed to the user with the new size. When the compositor receives .ack_configure, it can proceed to draw the new size.
 *
 * .ack_configure should be sent after every submitted configure sequence, passing along the serial received in it.
 *
 * An .ack_configure request is conceptually double-buffered.
 * Every request overrides the previous one. The request takes effect once the .commit request is sent on the corresponding surface.
 *
 * If the client receives multiple configure sequences before it
 * can respond to one, it may acknowledge only the last configure sequence by using its serial in the .ack_configure request.
 *
 * Committing an .ack_configure request consumes the serial number sent with
 * the request, as well as serial numbers sent by all configure sequences
 * submitted on this input_popup_surface prior to the configure sequence referenced by
 * the committed serial.
 *
 * Committing this request with a serial that, for this surface, never appeared in a submitted configure sequence, or one that was already committed before, raises an invalid_serial
 * error.
 */
static inline void
xx_input_popup_surface_v2_ack_configure(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_surface_v2,
			 XX_INPUT_POPUP_SURFACE_V2_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_surface_v2), 0, serial);
}

/**
 * @ingroup iface_xx_input_popup_surface_v2
 *
 * Reposition an already-mapped popup. The popup will be placed given the
 * details in the passed input_popup_positioner object.
 *
 * The request is processed immediately, without the need to issue wl_surface.commit, but the actual repositioning takes place later, after .ack_configure.
 *
 * The compositor should reply with a configure sequence including:
 * - input_popup_surface.start_configure,
 * - input_popup_surface.repositioned, including the token passed in this request.
 *
 * This will discard any parameters set by the previous positioner.
 *
 * If multiple .reposition requests are sent before the .repositioned event is submitted as part of a configure sequence, the compositor may ignore all
 * but the last one.
 *
 * The new popup position will not take
 * effect until the corresponding configure sequence is acknowledged by the
 * client. See input_popup_surface.repositioned for details. 
 *
 * The token itself is opaque, and has no other special meaning.
 */
static inline void
xx_input_popup_surface_v2_reposition(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2, struct xx_input_popup_positioner_v1 *positioner, uint32_t token)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_surface_v2,
			 XX_INPUT_POPUP_SURFACE_V2_REPOSITION, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_surface_v2), 0, positioner, token);
}

/**
 * @ingroup iface_xx_input_popup_surface_v2
 *
 * This destroys the popup. Explicitly destroying the input_popup_surface
 * object will also dismiss the popup, and unmap the surface.
 */
static inline void
xx_input_popup_surface_v2_destroy(struct xx_input_popup_surface_v2 *xx_input_popup_surface_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_surface_v2,
			 XX_INPUT_POPUP_SURFACE_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_surface_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef XX_INPUT_POPUP_POSITIONER_V1_ERROR_ENUM
#define XX_INPUT_POPUP_POSITIONER_V1_ERROR_ENUM
enum xx_input_popup_positioner_v1_error {
	/**
	 * invalid input provided
	 */
	XX_INPUT_POPUP_POSITIONER_V1_ERROR_INVALID_INPUT = 0,
};
#endif /* XX_INPUT_POPUP_POSITIONER_V1_ERROR_ENUM */

#ifndef XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_ENUM
#define XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_ENUM
enum xx_input_popup_positioner_v1_anchor {
	/**
	 * no edge, specfies center
	 */
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_NONE = 0,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_TOP = 1,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_BOTTOM = 2,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_LEFT = 3,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_RIGHT = 4,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_TOP_LEFT = 5,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_BOTTOM_LEFT = 6,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_TOP_RIGHT = 7,
	XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_BOTTOM_RIGHT = 8,
};
#endif /* XX_INPUT_POPUP_POSITIONER_V1_ANCHOR_ENUM */

#ifndef XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_ENUM
#define XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_ENUM
enum xx_input_popup_positioner_v1_gravity {
	/**
	 * center to center
	 */
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_NONE = 0,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_TOP = 1,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_BOTTOM = 2,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_LEFT = 3,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_RIGHT = 4,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_TOP_LEFT = 5,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_BOTTOM_LEFT = 6,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_TOP_RIGHT = 7,
	XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_BOTTOM_RIGHT = 8,
};
#endif /* XX_INPUT_POPUP_POSITIONER_V1_GRAVITY_ENUM */

#ifndef XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_ENUM
#define XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_ENUM
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 * constraint adjustments
 *
 * The constraint adjustment value define ways the compositor will adjust
 * the position of the surface, if the unadjusted position would result
 * in the surface being partly constrained.
 *
 * Whether a surface is considered 'constrained' is left to the compositor
 * to determine. For example, the surface may be partly outside the
 * compositor's defined 'work area', thus necessitating the child surface's
 * position be adjusted until it is entirely inside the work area.
 *
 * The adjustments can be combined, according to a defined precedence: 1)
 * Flip, 2) Slide, 3) Resize.
 */
enum xx_input_popup_positioner_v1_constraint_adjustment {
	/**
	 * don't move the surface when constrained
	 *
	 * Don't alter the surface position even if it is constrained on
	 * some axis, for example partially outside the edge of an output.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_NONE = 0,
	/**
	 * move along the x axis until unconstrained
	 *
	 * Slide the surface along the x axis until it is no longer
	 * constrained.
	 *
	 * First try to slide towards the direction of the gravity on the x
	 * axis until either the edge in the opposite direction of the
	 * gravity is unconstrained or the edge in the direction of the
	 * gravity is constrained.
	 *
	 * Then try to slide towards the opposite direction of the gravity
	 * on the x axis until either the edge in the direction of the
	 * gravity is unconstrained or the edge in the opposite direction
	 * of the gravity is constrained.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
	/**
	 * move along the y axis until unconstrained
	 *
	 * Slide the surface along the y axis until it is no longer
	 * constrained.
	 *
	 * First try to slide towards the direction of the gravity on the y
	 * axis until either the edge in the opposite direction of the
	 * gravity is unconstrained or the edge in the direction of the
	 * gravity is constrained.
	 *
	 * Then try to slide towards the opposite direction of the gravity
	 * on the y axis until either the edge in the direction of the
	 * gravity is unconstrained or the edge in the opposite direction
	 * of the gravity is constrained.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
	/**
	 * invert the anchor and gravity on the x axis
	 *
	 * Invert the anchor and gravity on the x axis if the surface is
	 * constrained on the x axis. For example, if the left edge of the
	 * surface is constrained, the gravity is 'left' and the anchor is
	 * 'left', change the gravity to 'right' and the anchor to 'right'.
	 *
	 * If the adjusted position also ends up being constrained, the
	 * resulting position of the flip_x adjustment will be the one
	 * before the adjustment.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
	/**
	 * invert the anchor and gravity on the y axis
	 *
	 * Invert the anchor and gravity on the y axis if the surface is
	 * constrained on the y axis. For example, if the bottom edge of
	 * the surface is constrained, the gravity is 'bottom' and the
	 * anchor is 'bottom', change the gravity to 'top' and the anchor
	 * to 'top'.
	 *
	 * The adjusted position is calculated given the original anchor
	 * rectangle and offset, but with the new flipped anchor and
	 * gravity values.
	 *
	 * If the adjusted position also ends up being constrained, the
	 * resulting position of the flip_y adjustment will be the one
	 * before the adjustment.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
	/**
	 * horizontally resize the surface
	 *
	 * Resize the surface horizontally so that it is completely
	 * unconstrained.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
	/**
	 * vertically resize the surface
	 *
	 * Resize the surface vertically so that it is completely
	 * unconstrained.
	 */
	XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
};
#endif /* XX_INPUT_POPUP_POSITIONER_V1_CONSTRAINT_ADJUSTMENT_ENUM */

#define XX_INPUT_POPUP_POSITIONER_V1_DESTROY 0
#define XX_INPUT_POPUP_POSITIONER_V1_SET_SIZE 1
#define XX_INPUT_POPUP_POSITIONER_V1_SET_ANCHOR 2
#define XX_INPUT_POPUP_POSITIONER_V1_SET_GRAVITY 3
#define XX_INPUT_POPUP_POSITIONER_V1_SET_CONSTRAINT_ADJUSTMENT 4
#define XX_INPUT_POPUP_POSITIONER_V1_SET_OFFSET 5
#define XX_INPUT_POPUP_POSITIONER_V1_SET_REACTIVE 6


/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_SET_SIZE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_SET_ANCHOR_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_SET_GRAVITY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_SET_OFFSET_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_popup_positioner_v1
 */
#define XX_INPUT_POPUP_POSITIONER_V1_SET_REACTIVE_SINCE_VERSION 1

/** @ingroup iface_xx_input_popup_positioner_v1 */
static inline void
xx_input_popup_positioner_v1_set_user_data(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xx_input_popup_positioner_v1, user_data);
}

/** @ingroup iface_xx_input_popup_positioner_v1 */
static inline void *
xx_input_popup_positioner_v1_get_user_data(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xx_input_popup_positioner_v1);
}

static inline uint32_t
xx_input_popup_positioner_v1_get_version(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * Notify the compositor that the positioner will no longer be used.
 */
static inline void
xx_input_popup_positioner_v1_destroy(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * Set the size of the surface that is to be positioned with the positioner
 * object. The size is in surface-local coordinates and corresponds to the
 * window geometry. See xdg_surface.set_window_geometry.
 *
 * If any dimension is set to zero, the invalid_input error is raised.
 */
static inline void
xx_input_popup_positioner_v1_set_size(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1, uint32_t width, uint32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), 0, width, height);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * Defines the anchor point for the anchor rectangle. The specified anchor
 * is used to derive an anchor point that the popup surface will be
 * positioned relative to. If a corner anchor is set (e.g. 'top_left' or
 * 'bottom_right'), the anchor point will be at the specified corner;
 * otherwise, the derived anchor point will be centered on the specified
 * edge, or in the center of the anchor rectangle if no edge is specified.
 */
static inline void
xx_input_popup_positioner_v1_set_anchor(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1, uint32_t anchor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), 0, anchor);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * Defines in what direction the surface should be positioned, relative to
 * the anchor point of the anchor rectangle. If a corner gravity is
 * specified (e.g. 'bottom_right' or 'top_left'), then the surface
 * will be placed towards the specified gravity; otherwise, the child
 * surface will be centered over the anchor point on any axis that had no
 * gravity specified. If the gravity is not in the ‘gravity’ enum, an
 * invalid_input error is raised.
 */
static inline void
xx_input_popup_positioner_v1_set_gravity(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1, uint32_t gravity)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_SET_GRAVITY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), 0, gravity);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * Specify how the popup should be positioned if the originally intended
 * position caused the surface to be constrained, meaning at least
 * partially outside positioning boundaries set by the compositor. The
 * adjustment is set by constructing a bitmask describing the adjustment to
 * be made when the surface is constrained on that axis.
 *
 * If no bit for one axis is set, the compositor will assume that the child
 * surface should not change its position on that axis when constrained.
 *
 * If more than one bit for one axis is set, the order of how adjustments
 * are applied is specified in the corresponding adjustment descriptions.
 *
 * The default adjustment is none.
 */
static inline void
xx_input_popup_positioner_v1_set_constraint_adjustment(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1, uint32_t constraint_adjustment)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_SET_CONSTRAINT_ADJUSTMENT, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), 0, constraint_adjustment);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * Specify the surface position offset relative to the position of the
 * anchor on the anchor rectangle and the anchor on the surface. For
 * example if the anchor of the anchor rectangle is at (x, y), the surface
 * has the gravity bottom|right, and the offset is (ox, oy), the calculated
 * surface position will be (x + ox, y + oy). The offset position of the
 * surface is the one used for constraint testing. See
 * set_constraint_adjustment.
 *
 * An example use case is placing a popup menu on top of a user interface
 * element, while aligning the user interface element of the parent surface
 * with some user interface element placed somewhere in the popup surface.
 */
static inline void
xx_input_popup_positioner_v1_set_offset(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_SET_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), 0, x, y);
}

/**
 * @ingroup iface_xx_input_popup_positioner_v1
 *
 * When set reactive, the surface is reconstrained if the conditions used
 * for constraining changed, e.g. the window containing the text input moved.
 *
 * Whenever the conditions change and the popup gets reconstrained, a
 * configure sequence is sent with updated geometry.
 */
static inline void
xx_input_popup_positioner_v1_set_reactive(struct xx_input_popup_positioner_v1 *xx_input_popup_positioner_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_popup_positioner_v1,
			 XX_INPUT_POPUP_POSITIONER_V1_SET_REACTIVE, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_popup_positioner_v1), 0);
}

#define XX_INPUT_METHOD_MANAGER_V2_GET_INPUT_METHOD 0
#define XX_INPUT_METHOD_MANAGER_V2_GET_POSITIONER 1
#define XX_INPUT_METHOD_MANAGER_V2_DESTROY 2


/**
 * @ingroup iface_xx_input_method_manager_v2
 */
#define XX_INPUT_METHOD_MANAGER_V2_GET_INPUT_METHOD_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_manager_v2
 */
#define XX_INPUT_METHOD_MANAGER_V2_GET_POSITIONER_SINCE_VERSION 1
/**
 * @ingroup iface_xx_input_method_manager_v2
 */
#define XX_INPUT_METHOD_MANAGER_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_xx_input_method_manager_v2 */
static inline void
xx_input_method_manager_v2_set_user_data(struct xx_input_method_manager_v2 *xx_input_method_manager_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xx_input_method_manager_v2, user_data);
}

/** @ingroup iface_xx_input_method_manager_v2 */
static inline void *
xx_input_method_manager_v2_get_user_data(struct xx_input_method_manager_v2 *xx_input_method_manager_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xx_input_method_manager_v2);
}

static inline uint32_t
xx_input_method_manager_v2_get_version(struct xx_input_method_manager_v2 *xx_input_method_manager_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) xx_input_method_manager_v2);
}

/**
 * @ingroup iface_xx_input_method_manager_v2
 *
 * Request a new input xx_input_method_v1 object associated with a given
 * seat.
 */
static inline struct xx_input_method_v1 *
xx_input_method_manager_v2_get_input_method(struct xx_input_method_manager_v2 *xx_input_method_manager_v2, struct wl_seat *seat)
{
	struct wl_proxy *input_method;

	input_method = wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_manager_v2,
			 XX_INPUT_METHOD_MANAGER_V2_GET_INPUT_METHOD, &xx_input_method_v1_interface, wl_proxy_get_version((struct wl_proxy *) xx_input_method_manager_v2), 0, seat, NULL);

	return (struct xx_input_method_v1 *) input_method;
}

/**
 * @ingroup iface_xx_input_method_manager_v2
 *
 * Create a positioner object. A positioner object is used to position
 * surfaces relative to some parent surface. See the interface description
 * and xdg_surface.get_popup for details.
 */
static inline struct xx_input_popup_positioner_v1 *
xx_input_method_manager_v2_get_positioner(struct xx_input_method_manager_v2 *xx_input_method_manager_v2)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_manager_v2,
			 XX_INPUT_METHOD_MANAGER_V2_GET_POSITIONER, &xx_input_popup_positioner_v1_interface, wl_proxy_get_version((struct wl_proxy *) xx_input_method_manager_v2), 0, NULL);

	return (struct xx_input_popup_positioner_v1 *) id;
}

/**
 * @ingroup iface_xx_input_method_manager_v2
 *
 * Destroys the xx_input_method_manager_v2 object.
 *
 * The xx_input_method_v1 objects originating from it remain valid.
 */
static inline void
xx_input_method_manager_v2_destroy(struct xx_input_method_manager_v2 *xx_input_method_manager_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_input_method_manager_v2,
			 XX_INPUT_METHOD_MANAGER_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_input_method_manager_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
