/* Generated by wayland-scanner 1.24.0 */

#ifndef KEYBOARD_FILTER_EXPERIMENTAL_V1_CLIENT_PROTOCOL_H
#define KEYBOARD_FILTER_EXPERIMENTAL_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_keyboard_filter_experimental_v1 The keyboard_filter_experimental_v1 protocol
 * filter and intercept keyboard events
 *
 * @section page_desc_keyboard_filter_experimental_v1 Description
 *
 * The keyboard_filter protocol allows a client to intercept selected keyboard events and prevent them from reaching the focused surface.
 *
 * This protocol offers a way to alter events reaching an application without the need to allow generating arbitrary keyboard events.
 *
 * High-level overview of the interfaces:
 *
 * The keyboard_filter_manager exposes the bind_to_input_method request which binds a wl_keyboard to an xx_input_method.
 * The resulting keyboard_filter object has the can be then used for intercepting keyboard events in accordance to input method needs.
 *
 * This document adheres to the RFC 2119 when using words like "must",
 * "should", "may", etc.
 *
 * Warning! The protocol described in this file is currently in the
 * experimental phase. Backwards incompatible major versions of the
 * protocol are to be expected. Exposing this protocol without an opt-in
 * mechanism is discouraged.
 *
 * @section page_ifaces_keyboard_filter_experimental_v1 Interfaces
 * - @subpage page_iface_xx_keyboard_filter_v1 - keyboard event filtering functionality
 * - @subpage page_iface_xx_keyboard_filter_manager_v1 - 
 * @section page_copyright_keyboard_filter_experimental_v1 Copyright
 * <pre>
 *
 * Copyright 2018 Mike Blumenkrantz
 * Copyright 2018 Samsung Electronics Co., Ltd
 * Copyright 2018 Red Hat Inc.
 * Copyright 2025 DorotaC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_keyboard;
struct wl_surface;
struct xx_input_method_v1;
struct xx_keyboard_filter_manager_v1;
struct xx_keyboard_filter_v1;

#ifndef XX_KEYBOARD_FILTER_V1_INTERFACE
#define XX_KEYBOARD_FILTER_V1_INTERFACE
/**
 * @page page_iface_xx_keyboard_filter_v1 xx_keyboard_filter_v1
 * @section page_iface_xx_keyboard_filter_v1_desc Description
 *
 * Manages the filtering of key presses.
 * @section page_iface_xx_keyboard_filter_v1_api API
 * See @ref iface_xx_keyboard_filter_v1.
 */
/**
 * @defgroup iface_xx_keyboard_filter_v1 The xx_keyboard_filter_v1 interface
 *
 * Manages the filtering of key presses.
 */
extern const struct wl_interface xx_keyboard_filter_v1_interface;
#endif
#ifndef XX_KEYBOARD_FILTER_MANAGER_V1_INTERFACE
#define XX_KEYBOARD_FILTER_MANAGER_V1_INTERFACE
/**
 * @page page_iface_xx_keyboard_filter_manager_v1 xx_keyboard_filter_manager_v1
 * @section page_iface_xx_keyboard_filter_manager_v1_api API
 * See @ref iface_xx_keyboard_filter_manager_v1.
 */
/**
 * @defgroup iface_xx_keyboard_filter_manager_v1 The xx_keyboard_filter_manager_v1 interface
 */
extern const struct wl_interface xx_keyboard_filter_manager_v1_interface;
#endif

#ifndef XX_KEYBOARD_FILTER_V1_ERROR_ENUM
#define XX_KEYBOARD_FILTER_V1_ERROR_ENUM
enum xx_keyboard_filter_v1_error {
	/**
	 * compositor received serial not adhering to requirements
	 */
	XX_KEYBOARD_FILTER_V1_ERROR_INVALID_SERIAL = 0x1,
};
#endif /* XX_KEYBOARD_FILTER_V1_ERROR_ENUM */

#ifndef XX_KEYBOARD_FILTER_V1_FILTER_ACTION_ENUM
#define XX_KEYBOARD_FILTER_V1_FILTER_ACTION_ENUM
enum xx_keyboard_filter_v1_filter_action {
	/**
	 * consume the key event
	 */
	XX_KEYBOARD_FILTER_V1_FILTER_ACTION_CONSUME = 0,
	/**
	 * pass the key event to the text input client
	 */
	XX_KEYBOARD_FILTER_V1_FILTER_ACTION_PASSTHROUGH = 1,
};
#endif /* XX_KEYBOARD_FILTER_V1_FILTER_ACTION_ENUM */

#define XX_KEYBOARD_FILTER_V1_UNBIND 0
#define XX_KEYBOARD_FILTER_V1_FILTER 1
#define XX_KEYBOARD_FILTER_V1_DESTROY 2


/**
 * @ingroup iface_xx_keyboard_filter_v1
 */
#define XX_KEYBOARD_FILTER_V1_UNBIND_SINCE_VERSION 1
/**
 * @ingroup iface_xx_keyboard_filter_v1
 */
#define XX_KEYBOARD_FILTER_V1_FILTER_SINCE_VERSION 1
/**
 * @ingroup iface_xx_keyboard_filter_v1
 */
#define XX_KEYBOARD_FILTER_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_xx_keyboard_filter_v1 */
static inline void
xx_keyboard_filter_v1_set_user_data(struct xx_keyboard_filter_v1 *xx_keyboard_filter_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xx_keyboard_filter_v1, user_data);
}

/** @ingroup iface_xx_keyboard_filter_v1 */
static inline void *
xx_keyboard_filter_v1_get_user_data(struct xx_keyboard_filter_v1 *xx_keyboard_filter_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xx_keyboard_filter_v1);
}

static inline uint32_t
xx_keyboard_filter_v1_get_version(struct xx_keyboard_filter_v1 *xx_keyboard_filter_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_v1);
}

/**
 * @ingroup iface_xx_keyboard_filter_v1
 *
 * Unbind the keyboard and stop intercepting events.
 *
 * Unbinds the bound keyboard and the input method. the compositor must stop redirecting keyboard events. Events that the keyboard_filter client has not yet responded to are treated as if they received the "passthrough" action.
 *
 * This request takes effect immediately.
 */
static inline void
xx_keyboard_filter_v1_unbind(struct xx_keyboard_filter_v1 *xx_keyboard_filter_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_keyboard_filter_v1,
			 XX_KEYBOARD_FILTER_V1_UNBIND, NULL, wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_v1), 0);
}

/**
 * @ingroup iface_xx_keyboard_filter_v1
 *
 * This request controls the filtering of keyboard input events before reaching the focused surface.
 *
 * Usage:
 *
 * While keyboard_filter is intercepting, the compositor must send every intercepted event to its bound wl_keyboard, and hold a copy of it in an internal queue.
 * When the client responds with the .filter request, the compositor either removes the event from the queue (filter_action.consume), or sends the copy to the original wl_keyboard objects (filter_action.passthrough).
 *
 * The compositor must process .filter the oldest event in the queue before processing more recent ones.
 * For this reason, the client sets the argument "serial" to the serial of the corresponding event it received.
 *
 * Exceptions:
 *
 * If the event is other than wl_keyboard.key or contains no serial, it cannot be filtered. The keyboard_filter client must not respond to it with .filter request. When such an event is oldest in the queue, the compositor must proceed as if the event had received a "passthrough" reply.
 *
 * As of wl_keyboard v10 and keyboard_filter_v1, the only event that can be filtered is the wl_keyboard.key event.
 *
 * Sequence:
 *
 * The wl_keyboard begins to receive events after input_method.activate is committed.
 * The valid serial is the serial of the oldest wl_keyboard event which has been sent after input_method.activate but which hasn't yet received a .filter confirmation.
 * The compositor may raise the invalid_serial error in response to events with serials it had not issued.
 * The compositor must ignore events with all other serials. (Particularly, this means events with repeating serials are accepted normally and are not ignored).
 * Events must be filtered in order of arrival.
 */
static inline void
xx_keyboard_filter_v1_filter(struct xx_keyboard_filter_v1 *xx_keyboard_filter_v1, uint32_t serial, uint32_t action)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_keyboard_filter_v1,
			 XX_KEYBOARD_FILTER_V1_FILTER, NULL, wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_v1), 0, serial, action);
}

/**
 * @ingroup iface_xx_keyboard_filter_v1
 *
 * Destroys the keyboard_filter object, stops event interception, and unbinds the wl_keyboard and input_method objects bound to it.
 */
static inline void
xx_keyboard_filter_v1_destroy(struct xx_keyboard_filter_v1 *xx_keyboard_filter_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_keyboard_filter_v1,
			 XX_KEYBOARD_FILTER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef XX_KEYBOARD_FILTER_MANAGER_V1_ERROR_ENUM
#define XX_KEYBOARD_FILTER_MANAGER_V1_ERROR_ENUM
enum xx_keyboard_filter_manager_v1_error {
	/**
	 * an argument is already bound
	 */
	XX_KEYBOARD_FILTER_MANAGER_V1_ERROR_ALREADY_BOUND = 0x1,
	/**
	 * the keyboard i attached to the wrong seat for this operation
	 */
	XX_KEYBOARD_FILTER_MANAGER_V1_ERROR_WRONG_SEAT = 0x2,
};
#endif /* XX_KEYBOARD_FILTER_MANAGER_V1_ERROR_ENUM */

#define XX_KEYBOARD_FILTER_MANAGER_V1_BIND_TO_INPUT_METHOD 0
#define XX_KEYBOARD_FILTER_MANAGER_V1_DESTROY 1


/**
 * @ingroup iface_xx_keyboard_filter_manager_v1
 */
#define XX_KEYBOARD_FILTER_MANAGER_V1_BIND_TO_INPUT_METHOD_SINCE_VERSION 1
/**
 * @ingroup iface_xx_keyboard_filter_manager_v1
 */
#define XX_KEYBOARD_FILTER_MANAGER_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_xx_keyboard_filter_manager_v1 */
static inline void
xx_keyboard_filter_manager_v1_set_user_data(struct xx_keyboard_filter_manager_v1 *xx_keyboard_filter_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xx_keyboard_filter_manager_v1, user_data);
}

/** @ingroup iface_xx_keyboard_filter_manager_v1 */
static inline void *
xx_keyboard_filter_manager_v1_get_user_data(struct xx_keyboard_filter_manager_v1 *xx_keyboard_filter_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xx_keyboard_filter_manager_v1);
}

static inline uint32_t
xx_keyboard_filter_manager_v1_get_version(struct xx_keyboard_filter_manager_v1 *xx_keyboard_filter_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_manager_v1);
}

/**
 * @ingroup iface_xx_keyboard_filter_manager_v1
 *
 * Bind a keyboard to an input method for the purpose of capturing key presses before they reach the text input client.
 *
 * When a wl_keyboard is bound, the compositor must redirect to it the input events intended for the focused surface with text input enabled. The wl_keyboard instance receives no other events from then on.
 * See keyboard_filter.filter.
 *
 * For the bound wl_keyboard instance to intercept events, the following conditions must be fulfilled:
 * - there's a focused surface,
 * - the surface has an enabled text input object,
 * - the bound input method is active (for the meaning of "active", see input_method.activate, input_method.deactivate).
 *
 * When those conditions are fulfilled, the compositor must start redirecting input events intended for the text input surface to the wl_keyboard bound with this request. Otherwise, the text input surface receives events without intercepting them.
 *
 * Be aware that the text input client might use a wl_keyboard object(s) of different version(s) than the one used by the input method. The compositor should issue events as it would normally do for the versions in question. This protocol assumes that events to multiple keyboards of different protocol versions are equivalent.
 *
 * Background:
 *
 * Whenever the input method is activated, the compositor must start sending it keyboard events intended for the text-input client, so that the input method can be controlled using a keyboard.
 * Traditionally, from the user perspective, input methods receive keys as if they were an overlay: keys which are interesting to the input method gain a special input method meaning, all others work as usual.
 * The binding and the keyboard_filter.filter request together make this possible by letting the input method indicate which events it is interested in.
 *
 * Conceptually, when a wl_keyboard is bound to an input_method, the compositor prevents all keyboard events directed to the text input client from reaching it. They are delayed until the input method decides how to filter them using the keyboard_filter.filter request.
 *
 * Arguments:
 *
 * The wl_keyboard must not be already bound to another interface.
 * The wl_keyboard must only receive events between committed .activate and .deactivate.
 *
 * The surface argument represents an arbitrary wl_surface. When issuing wl_keyboard.enter and wl_keyboard.leave on the bound wl_keyboard, the compositor must replace the original surface argument with the one provided by the input method in this request.
 *
 * Because the wl_keyboard.enter and wl_keyboard.leave events require a surface as the target, one must be provided even if the input method doesn't display one. A dummy one is sufficient. The provided wl_surface will not be used for any other purpose than explained above.
 *
 * The surface must outlive the input method.
 *
 * NOTE: This feature works much better with compositor-side key repeat introduced in wl_seat version 10. This protocol doesn't provide controls for filtering repeat key events generated client-side.
 * A compositor implementing this protocol should implement compositor-side key repeat.
 *
 * This request takes effect immediately.
 *
 * Attempting to bind a keyboard to an input method which is already bound must cause the already_bound error.
 * Attempting to bind a keyboard object which was already bound must cause the already_bound error.
 * Attempting to bind a keyboard object to an input method acting on a different seat must cause the wrong_seat error.
 *
 * Once any of the bound objects are destroyed, the xx_keyboard_filter_v1 instance becomes disabled and it must ignore all following requests.
 *
 * When the input method gets destroyed, the compositor must stop issuing events to the keyboard and ignore any further requests to keyboard_filter, except keyboard_filter.destroy.
 */
static inline struct xx_keyboard_filter_v1 *
xx_keyboard_filter_manager_v1_bind_to_input_method(struct xx_keyboard_filter_manager_v1 *xx_keyboard_filter_manager_v1, struct wl_keyboard *keyboard, struct xx_input_method_v1 *input_method, struct wl_surface *surface)
{
	struct wl_proxy *extensions;

	extensions = wl_proxy_marshal_flags((struct wl_proxy *) xx_keyboard_filter_manager_v1,
			 XX_KEYBOARD_FILTER_MANAGER_V1_BIND_TO_INPUT_METHOD, &xx_keyboard_filter_v1_interface, wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_manager_v1), 0, keyboard, input_method, surface, NULL);

	return (struct xx_keyboard_filter_v1 *) extensions;
}

/**
 * @ingroup iface_xx_keyboard_filter_manager_v1
 *
 * Destroys the xx_keyboard_filter_manager_v1 object.
 *
 * The xx_keyboard_filter_v1 objects originating from it remain unaffected.
 */
static inline void
xx_keyboard_filter_manager_v1_destroy(struct xx_keyboard_filter_manager_v1 *xx_keyboard_filter_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xx_keyboard_filter_manager_v1,
			 XX_KEYBOARD_FILTER_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xx_keyboard_filter_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
